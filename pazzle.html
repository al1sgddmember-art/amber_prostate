<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CMDDE — Lights Out (ライトアウト)</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1320;
    --tile-on:#ffd86b;
    --tile-off:#1f2a3a;
    --accent:#6ee7b7;
    --muted:#8b98a8;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;background:linear-gradient(180deg,var(--bg),#071021);color:#e6eef6}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:28px;box-sizing:border-box}
  .panel{
    width:420px;background:linear-gradient(180deg,var(--panel),#081623);border-radius:14px;padding:18px;box-shadow:0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03)
  }
  h1{margin:0 0 6px;font-size:20px}
  p.sub{margin:0 0 14px;color:var(--muted);font-size:13px}
  .topbar{display:flex;gap:8px;align-items:center;margin-bottom:12px}
  .btn{
    background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:var(--muted);cursor:pointer;font-size:13px
  }
  .btn.primary{background:linear-gradient(90deg,var(--accent),#5eead4);color:#042018;border:none}
  .status{margin-left:auto;font-size:13px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(5,64px);grid-gap:10px;justify-content:center;padding:10px 6px 16px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);margin-bottom:12px}
  .tile{
    width:64px;height:64px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;cursor:pointer;user-select:none;
    transition:transform .12s, box-shadow .12s, background-color .12s;
    border:1px solid rgba(255,255,255,0.04);
  }
  .tile:active{transform:scale(.98)}
  .on{background:linear-gradient(180deg,var(--tile-on),#ffc85a);box-shadow:0 8px 16px rgba(255,200,80,0.15);color:#0b1a17}
  .off{background:linear-gradient(180deg,var(--tile-off),#0f2130);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .footer{margin-top:10px;color:var(--muted);font-size:13px;text-align:center}
  .small{font-size:12px;color:var(--muted)}
  .hint{margin-top:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
  @media(max-width:480px){
    .panel{width:96%}
    .grid{grid-template-columns:repeat(5,calc((100% - 40px)/5));grid-gap:8px}
    .tile{height:calc((100% - 40px)/5)}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel" role="application" aria-label="Lights Out puzzle">
    <div class="topbar">
      <div>
        <h1>CMDDE — Lights Out</h1>
        <p class="sub">タイルをクリックすると、中心と上下左右が反転する。全て消せばクリア。</p>
      </div>
      <div class="status" id="status">Moves: 0</div>
    </div>

    <div class="grid" id="grid" aria-hidden="false"></div>

    <div class="controls" style="margin-bottom:8px">
      <button class="btn" id="shuffleBtn">ランダム生成</button>
      <button class="btn" id="resetBtn">リセット</button>
      <button class="btn" id="undoBtn">戻す</button>
      <button class="btn" id="hintBtn">ヒント</button>
      <button class="btn primary" id="solveBtn">解く（自動）</button>
    </div>

    <div class="hint" id="info">難易度：標準 5×5 — クリックで操作。ランダム生成で遊べ。最短解はヒントで1手分出す（完全解ではない場合あり）。</div>

    <div class="footer small">Made asap — save the file and開け</div>
  </div>
</div>

<script>
/*
  CMDDE Lights Out
  5x5 grid, click toggles tile + orthogonal neighbors.
  Features: shuffle, reset, undo, simple hint, automatic solve (Gaussian elim over GF(2))
*/

const SIZE = 5;
const gridEl = document.getElementById('grid');
const statusEl = document.getElementById('status');
const shuffleBtn = document.getElementById('shuffleBtn');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const hintBtn = document.getElementById('hintBtn');
const solveBtn = document.getElementById('solveBtn');
const infoEl = document.getElementById('info');

let state = new Array(SIZE*SIZE).fill(0); // 0 = off, 1 = on
let initialState = null;
let moveCount = 0;
let history = []; // stack of previous states
let tiles = [];

// create tiles
for(let i=0;i<SIZE*SIZE;i++){
  const div = document.createElement('div');
  div.className = 'tile off';
  div.dataset.idx = i;
  div.addEventListener('click', ()=>{ playerClick(i); });
  tiles.push(div);
  gridEl.appendChild(div);
}

function idx(r,c){ return r*SIZE + c; }
function neighbors(i){
  const r = Math.floor(i/SIZE), c = i%SIZE;
  const res = [i];
  if(r>0) res.push(idx(r-1,c));
  if(r<SIZE-1) res.push(idx(r+1,c));
  if(c>0) res.push(idx(r,c-1));
  if(c<SIZE-1) res.push(idx(r,c+1));
  return res;
}
function applyToggle(i, arr){
  for(const n of neighbors(i)){
    arr[n] ^= 1;
  }
}

function render(){
  for(let i=0;i<state.length;i++){
    tiles[i].className = 'tile ' + (state[i] ? 'on' : 'off');
    tiles[i].textContent = state[i] ? '' : '';
    tiles[i].ariaPressed = !!state[i];
  }
  statusEl.textContent = `Moves: ${moveCount}`;
  if(state.every(x=>x===0)){
    infoEl.textContent = `クリア！ ${moveCount}手で消したぜ。ランダムで再挑戦するなら「ランダム生成」押して。`;
  } else {
    infoEl.textContent = `難易度：標準 5×5 — Moves: ${moveCount}`;
  }
}

function playerClick(i){
  // save for undo
  history.push(state.slice());
  applyToggle(i, state);
  moveCount++;
  render();
}

function shuffle(randomClicks = 12){
  history = [];
  state = new Array(SIZE*SIZE).fill(0);
  for(let k=0;k<randomClicks;k++){
    const r = Math.floor(Math.random()*SIZE);
    const c = Math.floor(Math.random()*SIZE);
    applyToggle(idx(r,c), state);
  }
  initialState = state.slice();
  moveCount = 0;
  render();
}

function reset(){
  if(initialState) state = initialState.slice();
  else state = new Array(SIZE*SIZE).fill(0);
  history = [];
  moveCount = 0;
  render();
}

function undo(){
  if(history.length===0) return;
  state = history.pop();
  moveCount = Math.max(0, moveCount-1);
  render();
}

// Simple hint: compute one move from a solved linear system (if solvable) and show it (flash)
function hint(){
  const solution = solveSystem(state);
  if(!solution){
    infoEl.textContent = 'この配置は（このアルゴリズムでは）解けないかもしれん';
    return;
  }
  // find first nonzero move
  const first = solution.findIndex(x=>x===1);
  if(first===-1){
    infoEl.textContent = '既に解ける状態（または0手解）';
    return;
  }
  // flash that tile
  const el = tiles[first];
  el.style.transform = 'scale(1.06)';
  setTimeout(()=>el.style.transform='', 300);
  infoEl.textContent = `ヒント: インデックス ${first} を押すとよさげ`;
}

// Solve using linear algebra over GF(2)
// Represent matrix A (25x25) where A * x = b (mod 2), x = which tiles to press once
// Returns array x of length 25 of 0/1 or null if no solution
function solveSystem(bVec){
  const n = SIZE*SIZE;
  // build augmented matrix (n rows, n+1 cols)
  const M = [];
  for(let r=0;r<n;r++){
    const row = new Array(n+1).fill(0);
    // pressing tile c affects neighbors(c)
    for(let c=0;c<n;c++){
      const neigh = neighbors(c);
      if(neigh.includes(r)) row[c] = 1;
    }
    row[n] = bVec[r] % 2;
    M.push(row);
  }
  // Gaussian elimination mod 2
  let row = 0;
  for(let col=0;col<n && row<n;col++){
    // find pivot
    let sel = -1;
    for(let i=row;i<n;i++){
      if(M[i][col]===1){ sel = i; break;}
    }
    if(sel === -1) continue;
    // swap
    [M[row], M[sel]] = [M[sel], M[row]];
    // eliminate others
    for(let i=0;i<n;i++){
      if(i!==row && M[i][col]===1){
        for(let j=col;j<=n;j++){
          M[i][j] ^= M[row][j];
        }
      }
    }
    row++;
  }
  // check for inconsistency
  for(let i=row;i<n;i++){
    const allzero = M[i].slice(0,n).every(v=>v===0);
    if(allzero && M[i][n]===1) return null; // no solution
  }
  // Back-substitute (matrix is in RREF)
  const x = new Array(n).fill(0);
  for(let i=0;i<n;i++){
    // find leading 1
    const lead = M[i].slice(0,n).findIndex(v=>v===1);
    if(lead!==-1) x[lead] = M[i][n] % 2;
  }
  return x;
}

function autoSolve(){
  const sol = solveSystem(state);
  if(!sol){
    infoEl.textContent = '解が見つからない（または無い）';
    return;
  }
  // apply moves in sequence with small animation
  const moves = sol.map((v,i)=>v?i:-1).filter(v=>v!==-1);
  if(moves.length===0){
    infoEl.textContent = '既に消灯済みだよ';
    return;
  }
  // push current state for undo
  history.push(state.slice());
  let i = 0;
  const tick = ()=>{
    if(i>=moves.length){
      render();
      infoEl.textContent = `自動解法適用完了 — ${moves.length}手`;
      return;
    }
    const m = moves[i++];
    // animate tile flash
    const el = tiles[m];
    el.style.transform = 'scale(1.06)';
    setTimeout(()=>el.style.transform='', 140);
    applyToggle(m, state);
    moveCount++;
    render();
    setTimeout(tick, 160);
  };
  tick();
}

// wire buttons
shuffleBtn.addEventListener('click', ()=>shuffle(10 + Math.floor(Math.random()*8)));
resetBtn.addEventListener('click', reset);
undoBtn.addEventListener('click', undo);
hintBtn.addEventListener('click', hint);
solveBtn.addEventListener('click', autoSolve);

// initialize
shuffle(12);
render();

// keyboard support: arrows to move cursor + enter to press (optional)
let cursor = 0;
tiles.forEach((t, i)=>{
  t.tabIndex = 0;
  t.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault(); playerClick(i);
    }
  });
});
</script>
</body>
</html>
